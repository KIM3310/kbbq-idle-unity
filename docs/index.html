<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="google-adsense-account" content="ca-pub-0000000000000000" />
    <title>KBBQ Idle | Playable WebGL</title>
    <meta name="description" content="Play KBBQ Idle on Cloudflare Pages with optional backend integrations and policy-ready site sections." />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Silkscreen:wght@400;700&display=swap" rel="stylesheet" />
    <style>
      :root {
        --bg:#1a120f;
        --bg2:#281714;
        --card:#221814;
        --line:#5c3a29;
        --ink:#f7e5c7;
        --muted:#caaf88;
        --accent:#e86a2f;
        --accent-soft:#ffb25a;
      }
      * { box-sizing:border-box; }
      body {
        margin:0;
        font-family: "Silkscreen", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        color:var(--ink);
        background:
          radial-gradient(circle at 1px 1px, rgba(255, 182, 99, 0.12) 1px, transparent 0) 0 0/16px 16px,
          linear-gradient(160deg, var(--bg) 0%, var(--bg2) 100%);
      }
      header {
        padding:14px 20px;
        background:rgba(20, 13, 11, 0.86);
        border-bottom:1px solid var(--line);
        display:flex;
        gap:14px;
        flex-wrap:wrap;
        align-items:center;
        position:sticky;
        top:0;
        z-index:5;
        backdrop-filter: blur(6px);
      }
      header a { color:var(--accent-soft); text-decoration:none; font-size:12px; letter-spacing:.4px; }
      .wrap { max-width:1320px; margin:0 auto; padding:22px 14px 30px; display:grid; gap:14px; }
      .card {
        border:1px solid var(--line);
        background:linear-gradient(180deg, #2a1a15 0%, #221713 100%);
        border-radius:12px;
        padding:14px;
        box-shadow: 0 12px 26px rgba(0,0,0,.30);
      }
      h1,h2 { margin:0 0 10px; }
      h1 { font-size:24px; color:var(--accent-soft); letter-spacing:.8px; }
      h2 { font-size:18px; color:var(--accent-soft); }
      p,li { color:var(--muted); line-height:1.6; font-size:12px; }
      .playbox { display:grid; gap:12px; }
      .toolbar { display:flex; gap:8px; flex-wrap:wrap; }
      input,button {
        border-radius:8px;
        border:1px solid var(--line);
        padding:10px 12px;
        font-size:12px;
        font-family: inherit;
        color:var(--ink);
        background:#2c1d18;
      }
      input { min-width:220px; }
      button {
        background:linear-gradient(180deg, #6d2f18 0%, #542416 100%);
        cursor:pointer;
        transition: transform .08s ease, filter .15s ease;
      }
      button:hover { filter:brightness(1.1); }
      button:active { transform:translateY(1px); }
      #unityContainer {
        width:100%;
        min-height:0;
        aspect-ratio: 16 / 10;
        max-height: 78vh;
        border:1px solid var(--line);
        border-radius:10px;
        background:#100b09;
        display:flex;
        align-items:center;
        justify-content:center;
        overflow:hidden;
        position:relative;
      }
      #unityContainer::before {
        content:"";
        position:absolute;
        inset:0;
        pointer-events:none;
        border:2px solid rgba(255, 178, 90, .25);
        border-radius:10px;
        box-shadow: inset 0 0 40px rgba(0,0,0,.35);
      }
      #unityCanvas { width:100%; height:100%; display:none; image-rendering:pixelated; }
      #status { font-size:12px; color:var(--accent-soft); }
      #preflight { font-size:11px; color:var(--muted); line-height:1.5; }
      #adStatus { margin:8px 2px 0; font-size:11px; color:var(--muted); }
      .ad { min-height:96px; border:1px dashed var(--line); border-radius:10px; padding:8px; background:#1f1512; }
      footer { max-width:1320px; margin:0 auto; padding:0 16px 30px; color:var(--muted); font-size:11px; }
      @media (max-width: 900px) {
        #unityContainer { aspect-ratio: 4 / 3; max-height: none; }
        input { min-width: 160px; width: 100%; }
        .toolbar { flex-direction: column; }
      }
    </style>
  </head>
  <body>
    <header>
      <a href="./index.html">Play</a>
      <a href="./help.html">Help</a>
      <a href="./privacy.html">Privacy</a>
      <a href="./terms.html">Terms</a>
      <a href="./contact.html">Contact</a>
      <a href="./compliance.html">Compliance</a>
      <a href="https://github.com/KIM3310/kbbq-idle-unity">GitHub</a>
    </header>

    <main class="wrap">
      <section class="card playbox">
        <h1>KBBQ Idle WebGL</h1>
        <p>
          Unity WebGL build files must exist under <code>docs/Build/</code>. Set the build name below
          (for example <code>KBBQIdleWebGL</code>) and start.
        </p>
        <div class="toolbar">
          <input id="buildName" placeholder="Unity build base name" value="KBBQIdleWebGL" />
          <button id="checkBtn">Check Build Files</button>
          <button id="startBtn">Start Game</button>
          <button id="fullscreenBtn">Fullscreen</button>
        </div>
        <div id="status">Ready. Click Start Game after uploading WebGL build artifacts.</div>
        <div id="preflight">Tip: if your build uses `.unityweb`/`.br`/`.gz`, this page auto-detects those formats.</div>
        <div id="unityContainer">
          <canvas id="unityCanvas" width="960" height="600"></canvas>
        </div>
      </section>

      <section class="card">
        <h2>How to Play</h2>
        <ul>
          <li>Buy raw meat, place it on a grill slot, then flip and collect when it is ready.</li>
          <li>Serve customers with cooked inventory to keep queue flow and income stable.</li>
          <li>Use upgrades and boosts to speed up sizzle throughput and unlock better cuts.</li>
        </ul>
      </section>

      <section class="card">
        <h2>Trust & Policy</h2>
        <ul>
          <li>Support: use <a href="https://github.com/KIM3310/kbbq-idle-unity/issues">GitHub Issues</a> for bug reports and account-service requests.</li>
          <li>Privacy: gameplay/account telemetry is limited to service operation scope.</li>
          <li>Terms: in-game economy values may change during balancing updates.</li>
        </ul>
      </section>

      <section class="card">
        <h2>Sponsored Slot</h2>
        <div class="ad">
          <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-0000000000000000" data-ad-slot="1234567890" data-ad-format="auto" data-full-width-responsive="true"></ins>
          <p id="adStatus">Ad slot is in standby mode. Set real AdSense values to activate.</p>
        </div>
      </section>
    </main>

    <footer>
      Cloudflare Pages output directory: <code>docs</code> · Last updated: 2026-02-18
      <br />
      <span id="buildInfo">Build info: awaiting preflight.</span>
    </footer>

    <script>
      const canvas = document.getElementById('unityCanvas');
      const container = document.getElementById('unityContainer');
      const statusNode = document.getElementById('status');
      const preflightNode = document.getElementById('preflight');
      const buildInput = document.getElementById('buildName');
      const checkBtn = document.getElementById('checkBtn');
      const startBtn = document.getElementById('startBtn');
      const fullscreenBtn = document.getElementById('fullscreenBtn');
      const adNode = document.querySelector('.adsbygoogle');
      const adStatusNode = document.getElementById('adStatus');
      const buildInfoNode = document.getElementById('buildInfo');
      let unityInstance = null;
      let currentLoadId = 0;
      let buildManifestCache = null;
      let buildManifestFetched = false;
      const buildRevision = (() => {
        const fromLastModified = Date.parse(document.lastModified || '');
        if (Number.isFinite(fromLastModified) && fromLastModified > 0) {
          return String(fromLastModified);
        }
        return String(Math.floor(Date.now() / (60 * 1000)));
      })();

      function setStatus(text) {
        statusNode.textContent = text;
      }

      function setPreflight(text) {
        preflightNode.textContent = text;
      }

      function setBuildInfo(text) {
        if (buildInfoNode) {
          buildInfoNode.textContent = text;
        }
      }

      function setControlsEnabled(enabled) {
        const isEnabled = Boolean(enabled);
        buildInput.disabled = !isEnabled;
        checkBtn.disabled = !isEnabled;
        startBtn.disabled = !isEnabled;
      }

      function isHtmlContentType(contentType) {
        return typeof contentType === 'string' && contentType.toLowerCase().includes('text/html');
      }

      function withRevision(url) {
        const value = String(url || '');
        if (!value) return value;
        const joiner = value.includes('?') ? '&' : '?';
        return `${value}${joiner}v=${encodeURIComponent(buildRevision)}`;
      }

      async function fetchProbe(url, needsText = false) {
        const options = {
          method: 'GET',
          cache: 'no-store',
          headers: { Range: 'bytes=0-2047' },
        };

        const response = await fetch(url, options);
        const contentType = response.headers.get('content-type') || '';
        if (!response.ok || isHtmlContentType(contentType)) {
          return { ok: false, contentType, text: '' };
        }

        if (!needsText) {
          return { ok: true, contentType, text: '' };
        }

        const text = await response.text();
        const lowered = text.trimStart().toLowerCase();
        if (lowered.startsWith('<!doctype html') || lowered.startsWith('<html')) {
          return { ok: false, contentType, text };
        }

        return { ok: true, contentType, text };
      }

      async function urlExists(url) {
        try {
          const head = await fetch(url, { method: 'HEAD', cache: 'no-store' });
          const contentType = head.headers.get('content-type') || '';
          if (head.ok && !isHtmlContentType(contentType)) {
            return true;
          }
        } catch (_err) {
          // fallback below
        }

        try {
          const probe = await fetchProbe(url);
          return probe.ok;
        } catch (_err) {
          return false;
        }
      }

      async function pickCandidate(candidates, validator) {
        for (const candidate of candidates) {
          try {
            const candidateUrl = withRevision(candidate);
            const head = await fetch(candidateUrl, { method: 'HEAD', cache: 'no-store' });
            const headType = head.headers.get('content-type') || '';
            if (!head.ok || isHtmlContentType(headType)) {
              const fallback = await fetchProbe(candidateUrl, Boolean(validator));
              if (!fallback.ok) {
                continue;
              }
              if (!validator || validator(fallback.text, fallback.contentType)) {
                return candidateUrl;
              }
              continue;
            }

            if (!validator) {
              return candidateUrl;
            }

            const probe = await fetchProbe(candidateUrl, true);
            if (probe.ok && validator(probe.text, probe.contentType)) {
              return candidateUrl;
            }
          } catch (_err) {
            // try next
          }
        }
        return '';
      }

      function normalizeBuildPath(path, base) {
        const raw = String(path || '').trim();
        if (!raw) return '';
        if (raw.startsWith('http://') || raw.startsWith('https://') || raw.startsWith('Build/')) return raw;
        if (raw.startsWith('/')) return raw.slice(1);
        return `Build/${base}.${raw}`;
      }

      async function loadBuildManifest() {
        if (buildManifestFetched) {
          return buildManifestCache;
        }

        buildManifestFetched = true;
        try {
          const response = await fetch(withRevision('Build/build-manifest.json'), { cache: 'no-store' });
          const contentType = response.headers.get('content-type') || '';
          if (!response.ok || isHtmlContentType(contentType)) {
            buildManifestCache = null;
            return null;
          }
          const parsed = await response.json();
          if (!parsed || typeof parsed !== 'object') {
            buildManifestCache = null;
            return null;
          }
          buildManifestCache = parsed;
          const fileCount = Array.isArray(parsed.files) ? parsed.files.length : 0;
          const product = parsed.productName || 'KBBQ Idle';
          const version = parsed.productVersion || '1.0';
          const stamp = parsed.generatedAtUtc || 'unknown';
          setBuildInfo(`Build info: ${product} v${version} · files ${fileCount} · generated ${stamp}`);
          return buildManifestCache;
        } catch (_err) {
          buildManifestCache = null;
          setBuildInfo('Build info: manifest not found. Using runtime detection.');
          return null;
        }
      }

      async function resolveConfig(base) {
        const manifest = await loadBuildManifest();
        if (manifest && manifest.dataUrl && manifest.frameworkUrl && manifest.codeUrl) {
          const manifestBase = String(manifest.buildName || '').trim();
          const baseMatches = !manifestBase || manifestBase.toLowerCase() === base.toLowerCase();
          if (baseMatches) {
            return {
              dataUrl: withRevision(normalizeBuildPath(manifest.dataUrl, base)),
              frameworkUrl: withRevision(normalizeBuildPath(manifest.frameworkUrl, base)),
              codeUrl: withRevision(normalizeBuildPath(manifest.codeUrl, base)),
              symbolsUrl: manifest.symbolsUrl ? withRevision(normalizeBuildPath(manifest.symbolsUrl, base)) : undefined,
              loaderUrl: manifest.loaderUrl ? withRevision(normalizeBuildPath(manifest.loaderUrl, base)) : withRevision(`Build/${base}.loader.js`),
              companyName: manifest.companyName || 'KBBQ',
              productName: manifest.productName || 'KBBQ Idle',
              productVersion: manifest.productVersion || '1.0',
              streamingAssetsUrl: manifest.streamingAssetsUrl || 'StreamingAssets',
              autoSyncPersistentDataPath: true,
            };
          }
        }

        const direct = {
          dataUrl: withRevision(`Build/${base}.data`),
          frameworkUrl: withRevision(`Build/${base}.framework.js`),
          codeUrl: withRevision(`Build/${base}.wasm`),
          symbolsUrl: withRevision(`Build/${base}.symbols.json`),
        };
        if (await urlExists(direct.dataUrl) && await urlExists(direct.frameworkUrl) && await urlExists(direct.codeUrl)) {
          return {
            dataUrl: direct.dataUrl,
            frameworkUrl: direct.frameworkUrl,
            codeUrl: direct.codeUrl,
            symbolsUrl: (await urlExists(direct.symbolsUrl)) ? direct.symbolsUrl : undefined,
            loaderUrl: withRevision(`Build/${base}.loader.js`),
            streamingAssetsUrl: 'StreamingAssets',
            companyName: 'KBBQ',
            productName: 'KBBQ Idle',
            productVersion: '1.0',
            autoSyncPersistentDataPath: true,
          };
        }

        const candidates = {
          dataUrl: [
            `Build/${base}.data`,
            `Build/${base}.data.unityweb`,
            `Build/${base}.data.br`,
            `Build/${base}.data.gz`,
          ],
          frameworkUrl: [
            `Build/${base}.framework.js`,
            `Build/${base}.framework.js.unityweb`,
            `Build/${base}.framework.js.br`,
            `Build/${base}.framework.js.gz`,
          ],
          codeUrl: [
            `Build/${base}.wasm`,
            `Build/${base}.wasm.unityweb`,
            `Build/${base}.wasm.br`,
            `Build/${base}.wasm.gz`,
          ],
        };

        const resolved = {};
        resolved.dataUrl = await pickCandidate(candidates.dataUrl);
        resolved.frameworkUrl = await pickCandidate(candidates.frameworkUrl, (text) => text.includes('createUnityInstance') || text.includes('unityFramework'));
        resolved.codeUrl = await pickCandidate(candidates.codeUrl);

        if (!resolved.dataUrl || !resolved.frameworkUrl || !resolved.codeUrl) {
          throw new Error('Missing core build files (.data/.framework.js/.wasm).');
        }

        return {
          dataUrl: resolved.dataUrl,
          frameworkUrl: resolved.frameworkUrl,
          codeUrl: resolved.codeUrl,
          symbolsUrl: undefined,
          loaderUrl: withRevision(`Build/${base}.loader.js`),
          streamingAssetsUrl: 'StreamingAssets',
          companyName: 'KBBQ',
          productName: 'KBBQ Idle',
          productVersion: '1.0',
          autoSyncPersistentDataPath: true,
        };
      }

      async function preflightCheck(buildBase) {
        const base = String(buildBase || '').trim();
        if (!base) {
          setPreflight('Build name is required.');
          return null;
        }
        setPreflight('Scanning Build/ assets...');
        try {
          const config = await resolveConfig(base);
          setPreflight(`OK - data: ${config.dataUrl}, framework: ${config.frameworkUrl}, wasm: ${config.codeUrl}`);
          return config;
        } catch (err) {
          setPreflight(`Build check failed: ${err?.message || String(err)}`);
          return null;
        }
      }

      async function disposeUnityInstance() {
        if (!unityInstance || typeof unityInstance.Quit !== 'function') return;
        try {
          await unityInstance.Quit();
        } catch (_err) {
          // no-op
        }
        unityInstance = null;
      }

      async function loadUnity(buildBase) {
        const base = String(buildBase || '').trim();
        if (!base) {
          setStatus('Build name is required.');
          return;
        }

        if (typeof WebAssembly !== 'object') {
          setStatus('This browser does not support WebAssembly.');
          return;
        }

        const loadId = ++currentLoadId;
        setControlsEnabled(false);
        const config = await preflightCheck(base);
        if (!config) {
          setStatus('Cannot start. Build check failed.');
          setControlsEnabled(true);
          return;
        }

        await disposeUnityInstance();
        if (loadId !== currentLoadId) {
          setControlsEnabled(true);
          return;
        }

        setStatus('Loading Unity loader...');
        const loaderUrl = config.loaderUrl || withRevision(`Build/${base}.loader.js`);
        const existing = document.getElementById('unity-loader-script');
        if (existing) existing.remove();

        const script = document.createElement('script');
        script.id = 'unity-loader-script';
        script.src = loaderUrl;
        script.onload = () => {
          const createFn = window.createUnityInstance || (typeof createUnityInstance === 'function' ? createUnityInstance : null);
          if (typeof createFn !== 'function') {
            setStatus('Unity loader loaded but createUnityInstance is missing. Check build output.');
            setControlsEnabled(true);
            return;
          }
          setStatus('Initializing game...');
          canvas.style.display = 'block';
          createFn(canvas, config, (progress) => {
            setStatus(`Loading ${(progress * 100).toFixed(0)}%`);
          })
            .then((instance) => {
              if (loadId !== currentLoadId) {
                try { instance.Quit && instance.Quit(); } catch (_err) {}
                setControlsEnabled(true);
                return;
              }
              unityInstance = instance;
              setStatus('Game loaded.');
              setControlsEnabled(true);
            })
            .catch((err) => {
              setStatus(`Failed to launch: ${err}`);
              setControlsEnabled(true);
            });
        };
        script.onerror = () => {
          setStatus('Loader file not found. Build Unity WebGL and copy files into docs/Build/.');
          setControlsEnabled(true);
        };
        document.body.appendChild(script);
      }

      function setAdStatus(text) {
        if (adStatusNode) {
          adStatusNode.textContent = text;
        }
      }

      function hasConfiguredAdClient(client) {
        const raw = String(client || '').trim();
        if (!/^ca-pub-\d{8,20}$/.test(raw)) return false;
        return raw !== 'ca-pub-0000000000000000';
      }

      function hasConfiguredAdSlot(slot) {
        const raw = String(slot || '').trim();
        if (!/^\d{6,20}$/.test(raw)) return false;
        return raw !== '1234567890';
      }

      function shouldLoadAds() {
        const host = location.hostname;
        const isLocal = host === 'localhost' || host === '127.0.0.1';
        if (location.protocol !== 'https:' && !isLocal) {
          setAdStatus('Ads disabled: HTTPS is required.');
          return false;
        }

        return true;
      }

      function initializeAdsense() {
        if (!adNode) return;
        const client = adNode.getAttribute('data-ad-client') || '';
        const slot = adNode.getAttribute('data-ad-slot') || '';
        if (!hasConfiguredAdClient(client) || !hasConfiguredAdSlot(slot)) {
          setAdStatus('Ad slot is in standby mode. Set real AdSense values to activate.');
          return;
        }
        if (!shouldLoadAds()) return;

        const script = document.createElement('script');
        script.async = true;
        script.src = `https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=${encodeURIComponent(client)}`;
        script.crossOrigin = 'anonymous';
        script.onload = () => {
          try {
            (window.adsbygoogle = window.adsbygoogle || []).push({});
            setAdStatus('Ads active.');
          } catch (_err) {
            setAdStatus('Ad script loaded, but ad fill is pending.');
          }
        };
        script.onerror = () => {
          setAdStatus('Ad script failed to load. Check network policy and AdSense settings.');
        };
        document.head.appendChild(script);
      }

      checkBtn.addEventListener('click', () => {
        void preflightCheck(buildInput.value);
      });
      startBtn.addEventListener('click', () => loadUnity(buildInput.value));
      buildInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          void loadUnity(buildInput.value);
        }
      });
      fullscreenBtn.addEventListener('click', async () => {
        const target = container || canvas;
        if (!target) return;
        try {
          if (document.fullscreenElement) {
            await document.exitFullscreen();
          } else {
            await target.requestFullscreen();
          }
        } catch (_err) {
          setStatus('Fullscreen is not available in this browser.');
        }
      });
      document.addEventListener('keydown', (event) => {
        if (event.target && (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA')) return;
        if (event.key === 'f' || event.key === 'F') {
          event.preventDefault();
          fullscreenBtn.click();
        }
      });
      initializeAdsense();
    </script>
  </body>
</html>
