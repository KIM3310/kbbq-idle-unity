<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="google-adsense-account" content="ca-pub-0000000000000000" />
    <title>KBBQ Idle | Playable WebGL</title>
    <meta name="description" content="Play KBBQ Idle on Cloudflare Pages with optional backend integrations and policy-ready site sections." />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Silkscreen:wght@400;700&display=swap" rel="stylesheet" />
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0000000000000000" crossorigin="anonymous"></script>
    <style>
      :root {
        --bg:#1a120f;
        --bg2:#281714;
        --card:#221814;
        --line:#5c3a29;
        --ink:#f7e5c7;
        --muted:#caaf88;
        --accent:#e86a2f;
        --accent-soft:#ffb25a;
      }
      * { box-sizing:border-box; }
      body {
        margin:0;
        font-family: "Silkscreen", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        color:var(--ink);
        background:
          radial-gradient(circle at 1px 1px, rgba(255, 182, 99, 0.12) 1px, transparent 0) 0 0/16px 16px,
          linear-gradient(160deg, var(--bg) 0%, var(--bg2) 100%);
      }
      header {
        padding:14px 20px;
        background:rgba(20, 13, 11, 0.86);
        border-bottom:1px solid var(--line);
        display:flex;
        gap:14px;
        flex-wrap:wrap;
        align-items:center;
        position:sticky;
        top:0;
        z-index:5;
        backdrop-filter: blur(6px);
      }
      header a { color:var(--accent-soft); text-decoration:none; font-size:12px; letter-spacing:.4px; }
      .wrap { max-width:1320px; margin:0 auto; padding:22px 14px 30px; display:grid; gap:14px; }
      .card {
        border:1px solid var(--line);
        background:linear-gradient(180deg, #2a1a15 0%, #221713 100%);
        border-radius:12px;
        padding:14px;
        box-shadow: 0 12px 26px rgba(0,0,0,.30);
      }
      h1,h2 { margin:0 0 10px; }
      h1 { font-size:24px; color:var(--accent-soft); letter-spacing:.8px; }
      h2 { font-size:18px; color:var(--accent-soft); }
      p,li { color:var(--muted); line-height:1.6; font-size:12px; }
      .playbox { display:grid; gap:12px; }
      .toolbar { display:flex; gap:8px; flex-wrap:wrap; }
      input,button {
        border-radius:8px;
        border:1px solid var(--line);
        padding:10px 12px;
        font-size:12px;
        font-family: inherit;
        color:var(--ink);
        background:#2c1d18;
      }
      input { min-width:220px; }
      button {
        background:linear-gradient(180deg, #6d2f18 0%, #542416 100%);
        cursor:pointer;
        transition: transform .08s ease, filter .15s ease;
      }
      button:hover { filter:brightness(1.1); }
      button:active { transform:translateY(1px); }
      #unityContainer {
        width:100%;
        min-height:680px;
        border:1px solid var(--line);
        border-radius:10px;
        background:#100b09;
        display:flex;
        align-items:center;
        justify-content:center;
        overflow:hidden;
        position:relative;
      }
      #unityContainer::before {
        content:"";
        position:absolute;
        inset:0;
        pointer-events:none;
        border:2px solid rgba(255, 178, 90, .25);
        border-radius:10px;
        box-shadow: inset 0 0 40px rgba(0,0,0,.35);
      }
      #unityCanvas { width:100%; height:100%; display:none; image-rendering:pixelated; }
      #status { font-size:12px; color:var(--accent-soft); }
      #preflight { font-size:11px; color:var(--muted); line-height:1.5; }
      .ad { min-height:96px; border:1px dashed var(--line); border-radius:10px; padding:8px; background:#1f1512; }
      footer { max-width:1320px; margin:0 auto; padding:0 16px 30px; color:var(--muted); font-size:11px; }
      @media (max-width: 900px) {
        #unityContainer { min-height:460px; }
        input { min-width: 160px; width: 100%; }
        .toolbar { flex-direction: column; }
      }
    </style>
  </head>
  <body>
    <header>
      <a href="./index.html">Play</a>
      <a href="./privacy.html">Privacy</a>
      <a href="./terms.html">Terms</a>
      <a href="./contact.html">Contact</a>
      <a href="./compliance.html">Compliance</a>
      <a href="https://github.com/KIM3310/kbbq-idle-unity">GitHub</a>
    </header>

    <main class="wrap">
      <section class="card playbox">
        <h1>KBBQ Idle WebGL</h1>
        <p>
          Unity WebGL build files must exist under <code>docs/Build/</code>. Set the build name below
          (for example <code>KBBQIdleWebGL</code>) and start.
        </p>
        <div class="toolbar">
          <input id="buildName" placeholder="Unity build base name" value="KBBQIdleWebGL" />
          <button id="checkBtn">Check Build Files</button>
          <button id="startBtn">Start Game</button>
          <button id="fullscreenBtn">Fullscreen</button>
        </div>
        <div id="status">Ready. Click Start Game after uploading WebGL build artifacts.</div>
        <div id="preflight">Tip: if your build uses `.unityweb`/`.br`/`.gz`, this page auto-detects those formats.</div>
        <div id="unityContainer">
          <canvas id="unityCanvas" width="960" height="600"></canvas>
        </div>
      </section>

      <section class="card">
        <h2>Trust & Policy</h2>
        <ul>
          <li>Contact: kbbq-idle@ops.local</li>
          <li>Privacy: gameplay/account telemetry is limited to service operation scope.</li>
          <li>Terms: in-game economy values may change during balancing updates.</li>
        </ul>
      </section>

      <section class="card">
        <h2>Sponsored Slot</h2>
        <div class="ad">
          <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-0000000000000000" data-ad-slot="1234567890" data-ad-format="auto" data-full-width-responsive="true"></ins>
        </div>
      </section>
    </main>

    <footer>Cloudflare Pages output directory: <code>docs</code> Â· Last updated: 2026-02-18</footer>

    <script>
      const canvas = document.getElementById('unityCanvas');
      const container = document.getElementById('unityContainer');
      const statusNode = document.getElementById('status');
      const preflightNode = document.getElementById('preflight');
      const buildInput = document.getElementById('buildName');
      const checkBtn = document.getElementById('checkBtn');
      const startBtn = document.getElementById('startBtn');
      const fullscreenBtn = document.getElementById('fullscreenBtn');
      let unityInstance = null;
      const buildRevision = (() => {
        const fromLastModified = Date.parse(document.lastModified || '');
        if (Number.isFinite(fromLastModified) && fromLastModified > 0) {
          return String(fromLastModified);
        }
        return String(Math.floor(Date.now() / (60 * 1000)));
      })();

      function setStatus(text) {
        statusNode.textContent = text;
      }

      function setPreflight(text) {
        preflightNode.textContent = text;
      }

      function isHtmlContentType(contentType) {
        return typeof contentType === 'string' && contentType.toLowerCase().includes('text/html');
      }

      function withRevision(url) {
        const value = String(url || '');
        if (!value) return value;
        const joiner = value.includes('?') ? '&' : '?';
        return `${value}${joiner}v=${encodeURIComponent(buildRevision)}`;
      }

      async function fetchProbe(url, needsText = false) {
        const options = {
          method: 'GET',
          cache: 'no-store',
          headers: { Range: 'bytes=0-2047' },
        };

        const response = await fetch(url, options);
        const contentType = response.headers.get('content-type') || '';
        if (!response.ok || isHtmlContentType(contentType)) {
          return { ok: false, contentType, text: '' };
        }

        if (!needsText) {
          return { ok: true, contentType, text: '' };
        }

        const text = await response.text();
        const lowered = text.trimStart().toLowerCase();
        if (lowered.startsWith('<!doctype html') || lowered.startsWith('<html')) {
          return { ok: false, contentType, text };
        }

        return { ok: true, contentType, text };
      }

      async function urlExists(url) {
        try {
          const head = await fetch(url, { method: 'HEAD', cache: 'no-store' });
          const contentType = head.headers.get('content-type') || '';
          if (head.ok && !isHtmlContentType(contentType)) {
            return true;
          }
        } catch (_err) {
          // fallback below
        }

        try {
          const probe = await fetchProbe(url);
          return probe.ok;
        } catch (_err) {
          return false;
        }
      }

      async function pickCandidate(candidates, validator) {
        for (const candidate of candidates) {
          try {
            const candidateUrl = withRevision(candidate);
            const head = await fetch(candidateUrl, { method: 'HEAD', cache: 'no-store' });
            const headType = head.headers.get('content-type') || '';
            if (!head.ok || isHtmlContentType(headType)) {
              const fallback = await fetchProbe(candidateUrl, Boolean(validator));
              if (!fallback.ok) {
                continue;
              }
              if (!validator || validator(fallback.text, fallback.contentType)) {
                return candidateUrl;
              }
              continue;
            }

            if (!validator) {
              return candidateUrl;
            }

            const probe = await fetchProbe(candidateUrl, true);
            if (probe.ok && validator(probe.text, probe.contentType)) {
              return candidateUrl;
            }
          } catch (_err) {
            // try next
          }
        }
        return '';
      }

      function normalizeBuildPath(path, base) {
        const raw = String(path || '').trim();
        if (!raw) return '';
        if (raw.startsWith('http://') || raw.startsWith('https://') || raw.startsWith('Build/')) return raw;
        if (raw.startsWith('/')) return raw.slice(1);
        return `Build/${base}.${raw}`;
      }

      async function resolveConfig(base) {
        const jsonUrl = `Build/${base}.json`;
        try {
          const resp = await fetch(withRevision(jsonUrl), { cache: 'no-store' });
          if (resp.ok) {
            const parsed = await resp.json();
            if (parsed && parsed.dataUrl && parsed.frameworkUrl && parsed.codeUrl) {
              return {
                dataUrl: withRevision(normalizeBuildPath(parsed.dataUrl, base)),
                frameworkUrl: withRevision(normalizeBuildPath(parsed.frameworkUrl, base)),
                codeUrl: withRevision(normalizeBuildPath(parsed.codeUrl, base)),
                symbolsUrl: parsed.symbolsUrl ? withRevision(normalizeBuildPath(parsed.symbolsUrl, base)) : undefined,
                companyName: parsed.companyName || 'KBBQ',
                productName: parsed.productName || 'KBBQ Idle',
                productVersion: parsed.productVersion || '1.0',
                streamingAssetsUrl: parsed.streamingAssetsUrl || 'StreamingAssets',
              };
            }
          }
        } catch (_err) {
          // fall through to candidate scan
        }

        const candidates = {
          dataUrl: [
            `Build/${base}.data`,
            `Build/${base}.data.unityweb`,
            `Build/${base}.data.br`,
            `Build/${base}.data.gz`,
          ],
          frameworkUrl: [
            `Build/${base}.framework.js`,
            `Build/${base}.framework.js.unityweb`,
            `Build/${base}.framework.js.br`,
            `Build/${base}.framework.js.gz`,
          ],
          codeUrl: [
            `Build/${base}.wasm`,
            `Build/${base}.wasm.unityweb`,
            `Build/${base}.wasm.br`,
            `Build/${base}.wasm.gz`,
          ],
          symbolsUrl: [
            `Build/${base}.symbols.json`,
            `Build/${base}.symbols.json.unityweb`,
            `Build/${base}.symbols.json.br`,
            `Build/${base}.symbols.json.gz`,
          ],
        };

        const resolved = {};
        resolved.dataUrl = await pickCandidate(candidates.dataUrl);
        resolved.frameworkUrl = await pickCandidate(candidates.frameworkUrl, (text) => text.includes('createUnityInstance') || text.includes('unityFramework'));
        resolved.codeUrl = await pickCandidate(candidates.codeUrl);
        resolved.symbolsUrl = await pickCandidate(candidates.symbolsUrl);

        if (!resolved.dataUrl || !resolved.frameworkUrl || !resolved.codeUrl) {
          throw new Error('Missing core build files (.data/.framework.js/.wasm).');
        }

        return {
          dataUrl: resolved.dataUrl,
          frameworkUrl: resolved.frameworkUrl,
          codeUrl: resolved.codeUrl,
          symbolsUrl: resolved.symbolsUrl,
          streamingAssetsUrl: 'StreamingAssets',
          companyName: 'KBBQ',
          productName: 'KBBQ Idle',
          productVersion: '1.0',
        };
      }

      async function preflightCheck(buildBase) {
        const base = String(buildBase || '').trim();
        if (!base) {
          setPreflight('Build name is required.');
          return null;
        }
        setPreflight('Scanning Build/ assets...');
        try {
          const config = await resolveConfig(base);
          const symbols = config.symbolsUrl ? `, symbols: ${config.symbolsUrl}` : '';
          setPreflight(`OK - data: ${config.dataUrl}, framework: ${config.frameworkUrl}, wasm: ${config.codeUrl}${symbols}`);
          return config;
        } catch (err) {
          setPreflight(`Build check failed: ${err?.message || String(err)}`);
          return null;
        }
      }

      async function disposeUnityInstance() {
        if (!unityInstance || typeof unityInstance.Quit !== 'function') return;
        try {
          await unityInstance.Quit();
        } catch (_err) {
          // no-op
        }
        unityInstance = null;
      }

      async function loadUnity(buildBase) {
        const base = String(buildBase || '').trim();
        if (!base) {
          setStatus('Build name is required.');
          return;
        }

        if (typeof WebAssembly !== 'object') {
          setStatus('This browser does not support WebAssembly.');
          return;
        }

        const config = await preflightCheck(base);
        if (!config) {
          setStatus('Cannot start. Build check failed.');
          return;
        }

        await disposeUnityInstance();
        setStatus('Loading Unity loader...');
        const loaderUrl = withRevision(`Build/${base}.loader.js`);
        const existing = document.getElementById('unity-loader-script');
        if (existing) existing.remove();

        const script = document.createElement('script');
        script.id = 'unity-loader-script';
        script.src = loaderUrl;
        script.onload = () => {
          const createFn = window.createUnityInstance || (typeof createUnityInstance === 'function' ? createUnityInstance : null);
          if (typeof createFn !== 'function') {
            setStatus('Unity loader loaded but createUnityInstance is missing. Check build output.');
            return;
          }
          setStatus('Initializing game...');
          canvas.style.display = 'block';
          createFn(canvas, config, (progress) => {
            setStatus(`Loading ${(progress * 100).toFixed(0)}%`);
          })
            .then((instance) => {
              unityInstance = instance;
              setStatus('Game loaded.');
            })
            .catch((err) => setStatus(`Failed to launch: ${err}`));
        };
        script.onerror = () => {
          setStatus('Loader file not found. Build Unity WebGL and copy files into docs/Build/.');
        };
        document.body.appendChild(script);
      }

      checkBtn.addEventListener('click', () => {
        void preflightCheck(buildInput.value);
      });
      startBtn.addEventListener('click', () => loadUnity(buildInput.value));
      fullscreenBtn.addEventListener('click', async () => {
        const target = container || canvas;
        if (!target) return;
        try {
          if (document.fullscreenElement) {
            await document.exitFullscreen();
          } else {
            await target.requestFullscreen();
          }
        } catch (_err) {
          setStatus('Fullscreen is not available in this browser.');
        }
      });
      try { (window.adsbygoogle = window.adsbygoogle || []).push({}); } catch (e) {}
    </script>
  </body>
</html>
